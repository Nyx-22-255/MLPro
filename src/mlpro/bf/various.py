## -------------------------------------------------------------------------------------------------
## -- Project : FH-SWF Automation Technology - Common Code Base (CCB)
## -- Package : mlpro
## -- Module  : various
## -------------------------------------------------------------------------------------------------
## -- History :
## -- yyyy-mm-dd  Ver.      Auth.    Description
## -- 2021-04-16  0.0.0     DA       Creation
## -- 2021-05-29  1.0.0     DA       Release of first version
## -- 2021-06-16  1.1.0     SY       Adding the first version of data storing,
## --                                data plotting, and data saving classes
## -- 2021-06-17  1.2.0     DA       New abstract classes Loadable, Saveable
## -- 2021-06-21  1.3.0     SY       Add extensions in classes Loadable,
## --                                Saveable, DataPlotting & DataStoring.
## -- 2021-07-01  1.4.0     SY       Extend save/load functionalities
## -- 2021-08-20  1.5.0     DA       Added property class Plottable
## -- 2021-08-28  1.5.1     DA       Added constant C_VAR0 to class DataStoring
## -- 2021-09-11  1.5.0     MRD      Change Header information to match our new library name
## -------------------------------------------------------------------------------------------------

"""
Ver. 1.5.1 (2021-08-28)

This module provides various classes with elementry functionalities for reuse in
higher level classes. For example: logging, load/save, timer, ...
"""


from datetime import datetime, timedelta
from time import sleep
import numpy as np
import math
import matplotlib.pyplot as plt
import pickle as pkl
import os
import csv
import copy




## -------------------------------------------------------------------------------------------------
## -------------------------------------------------------------------------------------------------
class Loadable:
    """
    This abstract class adds the ability to be loadable to inherited classes. 
    """

## -------------------------------------------------------------------------------------------------
    @staticmethod    
    def load(p_path, p_filename):
        """
        Loads content from the given path and file name. If file does not exist, it returns None.

        Parameters:
            p_path          Path that contains the file 
            p_filename      File name

        Returns: 
            A loaded object, if file content was loaded successfully. None otherwise.
        """
        
        if not os.path.exists(p_path + os.sep + p_filename):
            return None
        
        return pkl.load(open(p_path + os.sep + p_filename, 'rb'))





## -------------------------------------------------------------------------------------------------
## -------------------------------------------------------------------------------------------------
class Saveable: 
    """
    This abstract class adds the ability to be saveable to inherited classes. The filename can be
    generated internally by implementing the method get_filename() or provided from outside otherwise.
    """

## -------------------------------------------------------------------------------------------------
    def generate_filename(self):
        """
        To be redefined in case of use of internal generated file names.

        Returns: 
            Returns an internal unique filename. 
        """

        return None


## -------------------------------------------------------------------------------------------------
    def save(self, p_path, p_filename=None) -> bool:
        """
        Saves content to the given path and file name. If file name is None, a unique file name will
        be generated by calling method generate_filename(). If it returns False then the saving method is failed. 

        Parameters:
            p_path          Path where file will be saved
            p_filename      File name (if None an internal filename will be generated)

        Returns: 
            True, if file content was saved successfully. False otherwise.
        """

        if ( p_filename is not None ) and ( p_filename != '' ):
            self.filename = p_filename
        else:
            self.filename = self.generate_filename()

        if self.filename is None:
            return False
        
        try:
            if not os.path.exists(p_path):
                os.makedirs(p_path)
            pkl.dump(self, open(p_path + os.sep + self.filename, "wb"))
            return True
        except:
            return False





## -------------------------------------------------------------------------------------------------
## -------------------------------------------------------------------------------------------------
class LoadSave (Loadable, Saveable): 
    """
    This abstract class adds the ability to be loadable and saveable to inherited classes. The 
    filename can be generated internally by implementing the method generate_filename() or provided 
    from outside otherwise. See classes Loadable and Saveable for further information.
    """
    
    pass






## -------------------------------------------------------------------------------------------------
## -------------------------------------------------------------------------------------------------
class Log:
    """
    This class adds elementry log functionality to inherited classes.
    """

    C_TYPE          = '????'
    C_NAME          = '????'

    C_LOG_TYPE_I    = 'I'           # Information
    C_LOG_TYPE_W    = 'W'           # Warning
    C_LOG_TYPE_E    = 'E'           # Error

## -------------------------------------------------------------------------------------------------
    def __init__(self, p_logging=True):
        """
        Parameters:
            p_logging     switch for logging 
        """

        self.switch_logging(p_logging)
        self.log(self.C_LOG_TYPE_I, 'Instantiated')


## -------------------------------------------------------------------------------------------------
    def switch_logging(self, p_logging:bool):
        """
        Switches log functionality on/off.

        Parameters:
            p_logging   switch for logging 
        """

        self.logging = p_logging 


## -------------------------------------------------------------------------------------------------
    def log(self, p_type, *p_args):
        """
        Writes log line to standard output in format:
        yyyy-mm-dd  hh:mm:ss.mmmmmm  [p_type  C_TYPE C_NAME]: [p_args] 

        Parameters:
            p_type      type of log entry
            p_args      log informations

        Returns: 
            Nothing
        """

        if not self.logging: return
        now = datetime.now()
        print('%04d-%02d-%02d  %02d:%02d:%02d.%06d ' % (now.year, now.month, now.day, now.hour, now.minute, now.second, now.microsecond), p_type + '  ' + self.C_TYPE + ' ' + self.C_NAME + ':', *p_args)





## -------------------------------------------------------------------------------------------------
## -------------------------------------------------------------------------------------------------
class Timer:
    """
    Timer class in two time modes (real/virtual) and with simple lap management.
    """

    C_MODE_REAL         = 0             # Real time 
    C_MODE_VIRTUAL      = 1             # Virtual time

    C_LAP_LIMIT         = 999999        

## -------------------------------------------------------------------------------------------------
    def __init__(self, p_mode, p_lap_duration:timedelta, p_lap_limit=C_LAP_LIMIT ) -> None:
        """
        Parameters:
            p_mode          C_MODE_REAL for real time mode,
                            C_MODE_VIRTUAL for virtual time mode
            p_lap_duration  Duration of a single lap
            p_lap_limit     maximum number of laps until the lap counter restarts with 0  
        """
        
        self.mode           = p_mode
        self.lap_duration   = p_lap_duration

        if p_lap_limit == 0:
            self.lap_limit = self.C_LAP_LIMIT
        else:
            self.lap_limit = p_lap_limit

        self.reset()


## -------------------------------------------------------------------------------------------------
    def reset(self) -> None:
        """
        Resets timer.

        Returns: 
            Nothing
        """

        self.time           = timedelta(0,0,0)
        self.lap_time       = timedelta(0,0,0)
        self.lap_id         = 0

        if self.mode == self.C_MODE_REAL:
            self.timer_start_real   = datetime.now()
            self.lap_start_real     = self.timer_start_real
            self.time_real          = self.timer_start_real


## -------------------------------------------------------------------------------------------------
    def get_time(self) -> timedelta:
        if self.mode == self.C_MODE_REAL:
            self.time_real  = datetime.now()
            self.time       = self.time_real - self.timer_start_real

        return self.time


## -------------------------------------------------------------------------------------------------
    def get_lap_time(self) -> timedelta:
        if self.mode == self.C_MODE_REAL:
            self.lap_time       = datetime.now() - self.lap_start_real

        return self.lap_time


## -------------------------------------------------------------------------------------------------
    def get_lap_id(self):
        return self.lap_id


## -------------------------------------------------------------------------------------------------
    def add_time(self, p_delta:timedelta):
        if self.mode == self.C_MODE_VIRTUAL:
            self.lap_time   = self.lap_time + p_delta
            self.time       = self.time + p_delta


## -------------------------------------------------------------------------------------------------
    def finish_lap(self) -> bool:
        """
        Finishes the current lap. In timer mode C_MODE_REAL the remaining time
        until the end of the lap will be paused. 

        Returns: 
            True, if the remaining time to the next lap was positive. False, if 
            the timer timed out.
        """
        
        timeout = False

        # Compute delay until next lap
        delay = self.lap_duration - self.get_lap_time()
        
        # Check for timeout
        if delay < timedelta(0,0,0): 
            timeout = True
            delay = timedelta(0,0,0)

        # Handle delay depending on timer mode
        if self.mode == self.C_MODE_REAL:
            # Wait until next lap start
            sleep(delay.total_seconds())
        else:
            # Just set next lap start time
            self.time = self.time + delay
            
        # Update lap data
        self.lap_id         = divmod( self.lap_id + 1, self.lap_limit )[1]
        self.lap_time       = timedelta(0,0,0)
        self.lap_start_real = datetime.now()

        return not timeout





## -------------------------------------------------------------------------------------------------
## -------------------------------------------------------------------------------------------------
class TStamp:
    """
    This class provides elementry time stamp functionality for inherited classes.
    """


## -------------------------------------------------------------------------------------------------
    def __init__(self, p_tstamp:timedelta=None):
        self.set_tstamp(p_tstamp)


## -------------------------------------------------------------------------------------------------
    def get_tstamp(self) -> timedelta:
        return self.tstamp


## -------------------------------------------------------------------------------------------------
    def set_tstamp(self, p_tstamp:timedelta):
        self.tstamp = p_tstamp





## -------------------------------------------------------------------------------------------------
## -------------------------------------------------------------------------------------------------
class DataStoring(LoadSave):
    """
    This class provides a functionality to store values of variables during
    training/simulation.
    """

    C_VAR0      = 'Frame ID'
    
## -------------------------------------------------------------------------------------------------
    def __init__(self, p_variables):
        """
        Parameters:
            p_variable    List of variable names
        """
        self.memory_dict    = {}
        self.names          = p_variables
        self.frame_id       = {}
        for name in self.names:
            self.memory_dict[name] = {}
            self.frame_id[name] = []


## -------------------------------------------------------------------------------------------------
    def add_frame(self, p_frame_id):
        """
        To store unique sections in a variable (e.g episodes in RL, etc.)
        """
        for name in self.names:
            self.memory_dict[name][p_frame_id] = []
            self.frame_id[name].append(p_frame_id)


## -------------------------------------------------------------------------------------------------
    def memorize(self, p_variable, p_frame_id, p_value):
        """
        To store a particular variable into a memory
        """
        self.memory_dict[p_variable][p_frame_id].append(p_value)


## -------------------------------------------------------------------------------------------------
    def get_values(self, p_variable, p_frame_id=None):
        """
        To obtain value from the memory
        """
        if p_frame_id == None:
            return self.memory_dict[p_variable]
        else:
            return self.memory_dict[p_variable][p_frame_id]
   
    
## -------------------------------------------------------------------------------------------------         
    def list_to_chunks(self, p_data, p_chunksize):
        NumChunks = int(math.ceil(len(p_data)/(p_chunksize * 1.0)))
        retval = []
        for chunk in range(NumChunks):
            retval.append(sum(p_data[chunk * p_chunksize : (chunk + 1) * p_chunksize])/(1.0 * p_chunksize))
        return retval


## -------------------------------------------------------------------------------------------------
    def compress(self, p_chunksize):
        for name in self.names:
            for ep in len(self.memory_dict[name]):
                self.memory_dict[name][ep] = self.list_to_chunks(self.memory_dict[name][ep], p_chunksize)


## -------------------------------------------------------------------------------------------------
    def save_data(self, p_path, p_filename=None, p_delimiter="\t") -> bool:
        """
        To save stored data in memory_dict as a readable file format
        """
        
        if ( p_filename is not None ) and ( p_filename != '' ):
            self.filename = p_filename
        else:
            self.filename = self.generate_filename()

        if self.filename is None:
            return False
        
        try:
            if not os.path.exists(p_path):
                os.makedirs(p_path)
            path_save = p_path+os.sep+self.filename+".csv"
            with open(path_save, "w", newline="") as write_file:
                header = copy.deepcopy(self.names)
                header.insert(0,self.C_VAR0)
                writer = csv.writer(write_file, delimiter=p_delimiter, quoting=csv.QUOTE_ALL)
                writer.writerow(header)
                writer = csv.writer(write_file, delimiter=p_delimiter)
                for frame in self.frame_id[self.names[0]]:
                    for idx in range(len(self.memory_dict[self.names[0]][frame])):
                        row = []
                        row.append(frame)
                        for name in self.names:
                            row.append(self.memory_dict[name][frame][idx])
                        writer.writerow(row)
            return True
        except:
            return False
        
        
## -------------------------------------------------------------------------------------------------
    def load_data(self, p_path, p_filename, p_delimiter="\t") -> bool:
        """
        To load data from a readable file format and store them into the DataStoring class format
        """
        
        try:
            path_load = p_path+os.sep+p_filename
            with open(path_load, "r") as read_file:
                reader = csv.reader(read_file, delimiter=p_delimiter)
                header = True
                for row in reader:
                    if header:
                        del row[0:1]
                        self.__init__(row)
                        header = False
                    else:
                        column = 1
                        for name in self.names:
                            if row[0] not in self.frame_id[name]:
                                self.add_frame(row[0])
                            self.memorize(name, row[0], float(row[column]))
                            column += 1
            return True
        except:
            return False





## -------------------------------------------------------------------------------------------------
## -------------------------------------------------------------------------------------------------
class DataPlotting(LoadSave):
    """
    This class provides a functionality to plot the stored values of variables.
    """


## -------------------------------------------------------------------------------------------------
    def __init__(self, p_data:DataStoring, p_window=100, p_showing=True, p_printing=None):
        """
        Parameters:
            p_data        Data object with stored variables values
            p_window      INT : Moving average parameter. default: 100
            p_showing     BOOL : Showing graphs after they are generated
            p_printing    Additional information for plotting at the end of
                          training.
                          [0] = Bool : Whether the stored values is plotted
                          [1] = Float : Min. value on graph
                          [2] = Float : Max. value on graph.
                                Set to -1, if you want to set min/max value
                                according to the stored values.
                          Example = {"p_variable_1" : [True,0,-1],
                                     "p_variable_2" : [True,-0.5,10]}
        """

        self.data       = p_data
        self.window     = p_window
        self.showing    = p_showing
        self.plots      = [[],[]]
        self.printing   = p_printing


## -------------------------------------------------------------------------------------------------
    def get_plots(self):
        """
        A function to plot data
        """
        for name in self.data.names:
            maxval  = 0
            if self.printing[name][0]:
                fig     = plt.figure(figsize=(7,7))
                lines   = []
                label   = []
                plt.title(name)
                plt.grid(True, which="both", axis="both")
                for fr in range(len(self.data.memory_dict[name])):
                    fr_id = self.data.frame_id[name][fr]
                    lines += plt.plot(self.moving_mean(self.data.get_values(name,fr_id),self.window), color="darkblue", alpha=(fr+1.0)/(len(self.data.memory_dict[name])+1))
                    if self.printing[name][2] == -1:
                        maxval = max(max(self.data.get_values(name,fr_id)), maxval)
                    else:
                        maxval = self.printing[name][2]
                    label.append("%s"%fr_id)
                plt.ylim(self.printing[name][1], maxval)
                plt.xlabel("cycles")
                plt.legend(label, bbox_to_anchor = (1,0.5), loc = "center left")
                self.plots[0].append(name)
                self.plots[1].append(fig)
                if self.showing:
                    plt.show()
                else:
                    plt.close(fig)


## -------------------------------------------------------------------------------------------------
    def moving_mean(self, p_inputs, p_window):
        """
        To create a series of averages of different subsets of the full data set.
        """
        inputs  = np.array(p_inputs)
        outputs = np.zeros_like(inputs)
        if len(inputs.shape) == 1:
            outputs = np.convolve(inputs, np.ones((p_window,))/p_window, mode='same')
        else:
            for col in range(inputs.shape[1]):
                outputs[:,col] = np.convolve(inputs[:,col], np.ones((p_window,))/p_window, mode='same')
        return outputs


## -------------------------------------------------------------------------------------------------
    def save_plots(self, p_path, p_format, p_dpi_mul=1):
        """
        This method is used to save generated plots.

        Parameters:
            p_path          Path where file will be saved
            p_format        Format of the saved file.
                            Options: 'eps', 'jpg', 'png', 'pdf', 'svg'
            p_dpi_mul       Saving plots parameter

        Returns: 
            True, if plots where saved successfully. False otherwise.
        """

        num_plots = len(self.plots[0])
        if num_plots == 0: return False

        try:
            if not os.path.exists(p_path):
                os.makedirs(p_path)
            for idx in range(num_plots):
                self.plots[1][idx].savefig(p_path + os.sep + self.plots[0][idx] + "." + p_format, dpi=500*p_dpi_mul, bbox_inches = 'tight')
            return True
        except:
            return False





## -------------------------------------------------------------------------------------------------
## -------------------------------------------------------------------------------------------------
class Plottable:
    """
    Property class that inherits the ability to be plottable.
    """

## -------------------------------------------------------------------------------------------------
    def init_plot(self, p_figure=None):
        """
        Initializes the plot. Optionally the plot itself will be embedded in a matplotlib figure.

        Parameters:
            p_figure            Optional MatPlotLib host figure, where the plot shall be embedded
        """

        pass


## -------------------------------------------------------------------------------------------------
    def update_plot(self):
        """
        Updates the plot.
        """

        pass

